@use "sass:map";
@use "sass:list";
@use "sass:math";
@use "sass:string";

/// Задает максимальную ширину и отступ для блока
///
/// @param {"left" | "right" | "all"} $side - направление растяжения
/// @param {bool} $indent-margin - делать отступ маржином (true) или падингом (false)
@mixin content-container($side: "all", $indent-margin: false) {
	box-sizing: border-box;

	$indent: if($indent-margin and $content-offset-over-min == 0, auto, $content-offset-over-min);

	@if ($indent-margin) {
		@if ($side == "all" or $side == "left") {
			margin-left: $indent;
		}

		@if ($side == "all" or $side == "right") {
			margin-right: $indent;
		}
	} @else {
		@if ($side == "all" or $side == "left") {
			padding-left: $indent;
		}

		@if ($side == "all" or $side == "right") {
			padding-right: $indent;
		}
	}

	@each $key, $val in $site-breakpoints {
		@media (min-width: $val) {
			$indent: if($indent-margin and map.get($content-offsets, $key) == 0, auto, map.get($content-offsets, $key));

			@if ($indent-margin) {
				@if ($side == "all" or $side == "left") {
					margin-left: $indent;
				}

				@if ($side == "all" or $side == "right") {
					margin-right: $indent;
				}
			} @else {
				@if ($side == "all" or $side == "left") {
					padding-left: $indent;
				}

				@if ($side == "all" or $side == "right") {
					padding-right: $indent;
				}
			}
		}
	}
}

// Для переданного css свойства устанавливает значение переменной $content-offsets
@mixin get-content-offsets-value($css-property) {
	#{$css-property}: $content-offset-over-min;

	@each $key, $val in $site-breakpoints {
		$value: map.get($content-offsets, $key);

		@media (min-width: $val) {
			#{$css-property}: $value;
		}
	}
}

// Для переданного css свойства устанавливает значение переменной $main-width
@mixin get-main-width-value($css-property) {
	#{$css-property}: $main-offset-over-mix;

	@each $key, $val in $site-breakpoints {
		$value: map.get($main-width, $key);

		@media (min-width: $val) {
			#{$css-property}: $value;
		}
	}
}

// Для переданного css свойства устанавливает значение выражения $content-offsets + $main-width
@mixin get-all-size-value($css-property) {
	#{$css-property}: $main-offset-over-mix + $content-offset-over-min;

	@each $key, $val in $site-breakpoints {
		$value: map.get($main-width, $key) + map.get($content-offsets, $key);

		@media (min-width: $val) {
			#{$css-property}: $value;
		}
	}
}

// Ограничивает кол-во строчек текста
@mixin limit-text-lines-count($line-count) {
	-ms-text-overflow: ellipsis;
	-o-text-overflow: ellipsis;
	text-overflow: ellipsis;
	overflow: hidden;
	-ms-line-clamp: $line-count;
	-webkit-line-clamp: $line-count;
	line-clamp: $line-count;
	display: -webkit-box;
	word-wrap: break-word;
	-webkit-box-orient: vertical;
}

/// Задает max-width для работы резиновых отступов
@mixin main-container($side: "all") {
	@if ($side == "all") {
		max-width: $main-width-over-min;
	} @else {
		max-width: $main-width-over-min - $content-offset-over-min;
	}

	@each $key, $val in $site-breakpoints {
		@media (min-width: $val) {
			@if ($side == "all") {
				max-width: map.get($main-width, $key);
			} @else {
				max-width: map.get($main-width, $key) - map.get($content-offsets, $key);
			}
		}
	}

	margin: 0 auto;
}

/// Задает брейкпоинт по ширине
///
/// @param {breakpoints | size} $size - требуемый брейкпоинт
/// @param {"up" | "down"} $direction - направление min-width (up) или max-width (down)
/// @param {"" | "portrait" | "landscape"} $orientation - добавить к условию ориентацию экрана
///
/// @example
/// @include for-width ("max") {
///     width: 50%;
/// }
@mixin for-width($size, $direction: "up", $orientation: "") {
	$media-rule: "";
	$media: "min-width";
	$sizee: "";

	@if ($direction == "down") {
		$media: "max-width";
	}

	@if ($orientation != "") {
		$media-rule: "(orientation: " + $orientation + ") and ";
	}

	@if (map.get($site-breakpoints, $size)) {
		$sizee: map.get($site-breakpoints, $size);
	} @else {
		$sizee: map.get($breakpoints-width, $size);
	}

	@if (not $sizee) {
		$sizee: $size;
	}

	@if ($direction == "down") {
		$sizee: $sizee - 1;
	}

	@media #{$media-rule + "(" + $media + ": " + $sizee + ")"} {
		@content;
	}
}

/// Задает брейкпоинт по высоте
///
/// @param {breakpoints | size} $size - требуемый брейкпоинт
/// @param {"up" | "down"} $direction - направление min-height (up) или max-height (down)
/// @param {"" | "portrait" | "landscape"} $orientation - добавить к условию ориентацию экрана
///
/// @example
/// @include for-height ("max") {
///     height: 1000px;
/// }
@mixin for-height($size, $direction: "up", $orientation: "") {
	$media-rule: "";
	$media: "min-height";
	$sizee: "";

	@if ($direction == "down") {
		$media: "max-height";
	}

	@if ($orientation != "") {
		$media-rule: "(orientation: " + $orientation + ") and ";
	}

	@if (map.get($site-breakpoints, $size)) {
		$sizee: map.get($site-breakpoints, $size);
	} @else {
		$sizee: map.get($breakpoints-height, $size);
	}

	@if (not $sizee) {
		$sizee: $size;
	}

	@if ($direction == "down") {
		$sizee: $sizee - 1;
	}

	@media #{$media-rule + "(" + $media + ": " + $sizee + ")"} {
		@content;
	}
}

/// Растягивает элемент на всю ширину окна
///
/// @param {"left" | "right" | "all"} $side - направление растяжения
@mixin layout-negative-margin($side: left) {
	$indent: calc((50vw - 50%) * -1);

	@if ($side == "left") {
		width: calc(100% + ((100vw - 100%) / 2)) !important;
		margin-left: #{$indent} !important;
	}

	@if ($side == "right") {
		width: calc(100% + ((100vw - 100%) / 2)) !important;
		margin-right: #{$indent} !important;
	}

	@if ($side == "all") {
		width: 100vw !important;
		margin-left: #{$indent} !important;
		margin-right: #{$indent} !important;
	}
}

/// Вычисляет половину от любой единицы измерения
/// Используется для вычисления gutter в резиновых отступах
///
/// @param {size} $gutter - резиновый отступ
@function half-gutter($gutter: $gutter-grid) {
	$margin-em-val: strip-unit($gutter);
	$margin-em-unit: math.unit($gutter);
	$margin: math.div($margin-em-val, 2);
	$margin: $margin + $margin-em-unit;

	@return $margin;
}

/// Вычисляет ширину в зависимости от переданных данных
///
/// @param {number | percent | list} $size - требуемый размер
///
/// @example
/// get-width(2); // 50%
/// get-width(20%); // 20%
/// get-width(300px); // 300px
/// get-width(1 of 12); // 8.333%
@function get-width($size: 0) {
	$width: 100%;

	@if ($size != 0) {
		@if (type-of($size) == "number") {
			@if (unit($size) == "") {
				$width: (100 / $size) + "%";
			} @else {
				$width: $size;
			}
		} @else if (type-of($size) == "list") {
			@if (length($size) > 2) {
				$width: math.percentage(math.div(list.nth($size, 1), list.nth($size, 3)));
			}
		}
	}

	@return #{$width};
}

/// Миксин для сетки
///
/// @param {grid-template-value} $template-columns - размер столбцов через grid-template-columns
/// @param {gap-value} $gap - отступ между элементами
@mixin grid-container($template-columns, $gap: false) {
	display: grid;
	grid-template-columns: $template-columns;

	@if ($gap == false) {
		gap: $gutter-size-over-min;

		@each $key, $val in $site-breakpoints {
			@media (min-width: $val) {
				gap: map.get($gutter-size, $key);
			}
		}
	} @else {
		gap: $gap;
	}
}

/// Функция расчета ширины контентной части исходя из резиновых отступов
///
/// @param {breakpoint} $breakpoint - брейкпоинт для которого производится расчёт
/// @param {size} $padding-elastic - размер резинового отступа на заданном брейкпоинте
@function calc-width($breakpoint, $padding-elastic) {
	$window-width: map.get($site-breakpoints, $breakpoint);

	@return $window-width - $padding-elastic * 2;
}

@mixin font-face($name, $path, $weight: normal, $style: normal, $woff2: false) {
	$src: if($woff2, list.append(null, url($path + ".woff2") format(string.quote("woff2"))), null);
	$src: list.append($src, url($path + ".woff") format(string.quote("woff")), comma);

	@font-face {
		font-family: string.quote($name);
		font-style: $style;
		font-weight: $weight;
		src: $src;
	}
}
